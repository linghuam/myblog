---
title: 前端一些问题的深入
comments: true
date: 2018-3-3 17:20:26
tags:
  - 前端
categories:
  - 前端
---

### js 事件循环本质？

```js
setTimeout(() => console.log('a'), 0);
var p = new Promise((resolve) => {
  console.log('b');
  resolve();
});
p.then(() => console.log('c'));
p.then(() => console.log('d'));
console.log('e');
// 结果：b e c d a
```
{% asset_img a.png 截图 %}

- 引擎：解释并编译代码，让它变成能交给机器运行的代码（runnable commands）。
- runtime：就是运行环境，它提供一些对外接口供Js调用，以跟外界打交道，比如，浏览器环境、Node.js环境。不同的runtime，会提供不同的接口，比如，在 Node.js 环境中，我们可以通过 require 来引入模块；而在浏览器中，我们有 window、 DOM。
-
- macro-task（宏任务）: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering
- micro-task（微任务）: process.nextTick, Promise(原生)，Object.observe，MutationObserver

参考：
- https://segmentfault.com/a/1190000011198232
- https://zhuanlan.zhihu.com/p/30763076
- https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
- https://stackoverflow.com/questions/29027845/what-is-the-difference-between-javascript-engine-and-javascript-runtime-environm
- https://github.com/aooy/blog/issues/5
- http://www.ruanyifeng.com/blog/2014/10/event-loop.html

### 函数柯里化？

```js
// 将一个普通函数 fn 柯里化
function curry(fn){
  var slice = Array.prototype.slice;
  var oldArgs = slice.call(arguments, 1);
  return function (){
    var newArgs = slice.call(arguments);
    var args = oldArgs.concat(newArgs);
    return fn.apply(null, args); // apply 的返回值为 fn 函数返回值
  }
}
// test
function add (x, y){
  return x + y;
}
var curryAdd = curry(add,1);
curryAdd(2);
```
