---
title: 前端面试-浏览器
comments: true
date: 2018-01-30 23:41:20
tags:
  - 浏览器
categories:
  - 前端面试
---

## 浏览器
<!-- more -->

### 浏览器渲染原理?

**过程：**解析 HTML 构建 DOM 树、解析 CSS 构建 Render 树 -> Layout -> Paint -> Composite。

期间可引起重绘和重排。

**减少重绘和重排方法：**
 - 不要频繁操作 DOM，应该合并处理；
 - position 设为 fixed 或 absolute；
 - 不要用 table 布局；
 - 尽量使用 css 动画。


### HTML页面加载和解析流程?
1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；
2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；
3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；
4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；
5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；
6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；
7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；
8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；
9. 终于等到了＜/html＞的到来，浏览器泪流满面……
10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；
11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。


### session、cookie、sessionStorage、localStorage等区别?
详见：http://www.jb51.net/article/122101.htm

Cookie/Session机制详解：http://blog.csdn.net/fangaoxin/article/details/6952954

cookie存储在客户端，session存储在服务端，通过 session id 来识别客户端， session id存储在cookie中或url中。

移动端不支持 cookie，可通过将 session id 写入 URL 来记录用户状态。

当客户端第一次请求session对象时，服务端生成一个id并发送给客户端，客户端在下次请求时，再将这个id发送给服务端。

cookie安全性不好，session安全，但服务端压力大。


**存储大小：**
- cookie 数据大小不能超过4k。
- sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。
**有期时间：**
- localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
- sessionStorage  数据在当前浏览器窗口关闭后自动删除。
- cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
**作用域不同:**
- sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；
- localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

### Cookie 组成？ http://www.xuebuyuan.com/889016.html
Cookie格式如下:

Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE

Secure：在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时，浏览器才向服务器提交相应的Cookie。当前这种协议只有一种，即为HTTPS。

###  浏览器发送cookie时会发送哪几个部分?

```
HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value; expires=失效时间; domain=域名
```

###  Cookie 是否会被覆盖，localStorage是否会被覆盖?
Cookie是可以覆盖的，如果重复写入同名的Cookie，那么将会覆盖之前的Cookie

如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表Cookie只保存在内存中，浏览器关闭即消失。

localStorage存储在一个对象中，如果重复写入同名的 key，也会覆盖之前的 key。


### http？[详解](https://www.jianshu.com/p/6aa2fda4d4a1)

**协议分层：** http应用层 ——> TCP传输层 ——> IP网络层 ——> 链路层（网络接口）——> 物理层（网卡）

**封装：**发送端在层与层传输数据时，每经过一层必定会打上改成所属的首部信息；接收端在层与层传输数据
时，每经过一层会把对应的首部消去。

### http 请求方法？

HTTP1.0定义了三种请求方法：GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：PUT, DELETE, OPTIONS, TRACE 和 CONNECT 方法。

1. | GET | 请求指定的页面信息，并返回实体主体。
2. | HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
3. | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4. | PUT | 从客户端向服务器传送的数据取代指定的文档的内容。
5. | DELETE | 	请求服务器删除指定的页面。
6. | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7. | OPTIONS | 询问的请求，如CORS的预检请求。允许客户端查看服务器的性能。
8. | TRACE | 回显服务器收到的请求，主要用于测试或诊断。

### https？

加密处理防止窃听。可通过SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输协议）的组合使用，加密通信。与SSL组合使用的HTTP叫HTTPS。


### 从输入网址到看到页面的过程？
从输入URL到浏览器显示页面发生了什么：http://www.cnblogs.com/kongxy/p/4615226.html

1. 用户输入网址
2. 浏览器通过 DNS 获取网站的 IP 地址
3. 浏览器客户端发送 http 请求
4. 传输层 TCP 传输报文
5. 网络层 IP 协议查询 MAC 地址
6. 数据到达数据链路层
7. 服务器接收数据
8. 服务器响应请求
9. 服务器返回响应文
10. 页面渲染：解析 HTML 构建 DOM 树 -> 构建渲染树 -> 布局渲染树 -> 绘制渲染树

### 浏览器主要渲染过程？
1. 浏览器解析html源码, 创建一棵DOM树
2. 浏览器解析CSS代码, 计算出最终的样式数据
3. js解析因为文件在加载的同时也进行解析
4. 构建DOM树, 并且计算出样式数据后, 下一步就是构建一棵渲染树(rendering tree)
   - 渲染树和DOM树有区别, DOM树完全与html标签一一对应, 但是渲染树会忽略掉不需要渲染的元素, 比如head, display: none的元素等
   - 一大段文本中的每一行在渲染树中都是一个独立的节点
   - 渲染树的每一个节点都存储有对应的css属性
5. 渲染树创建好, 浏览器就可以根据渲染树直接把页面绘制到屏幕上

### post、get区别？
1. 本质都是 TCP 连接，并无区别，只是贴上不同的标签，便于处理
2. get 只产生一个 TCP 数据包， post 产生两个 TCP数据包
3. get 在一次请求中将 header 和 data 发送给服务器，服务器返回 200
4. post 先发送 header 再 发送 data

5. get请求一般用于向服务器查询某些信息, post请求通常用于向服务器发送应该被保存的数据
6. get请求可以将查询字符串参数追加到url的末尾; post请求应该把数据作为请求的主体提交
7. 因为get请求提交的数据直接加载url末尾,所以其大小有限制; 理论来讲, post是没有大小限制的
8. post安全性比get要高
9. get可以缓存，post不能缓存
10. get对搜索引擎友好
11. 对于get方式, 服务器端用Request.QueryString获取变量的值, 对于post方式, 服务器端用Request.Form获取提交的数据


### 缓存？

浏览器缓存知识小结及应用：http://www.cnblogs.com/lyzg/p/5125934.html

- 200 ok ：当浏览器没有缓存，或用户强制刷新，浏览器直接获取最新数据。
- 304：由 last-modified/etag 控制。先发送请求到服务器，如果没有变化，返回304。
- 200 from cache：由 expires/cache-control 控制。

策略：[详情](http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html)
- Expires 缺点:绝对时间
- Cache-Control 相对时间 max-age 控制缓存在时间
- Last-Modified/If-Modified-Since
- Etag/If-None-Match

### 强缓存和协商缓存的命中和管理？
1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。

2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源。

3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

### 强缓存？

1. 当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为 200，在 chrome 的开发者工具的 network 里面 size会显示为 from cache。

2. 强缓存是利用 **Expires** 或者 **Cache-Control** 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。

 **Expires:** 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个**绝对时间**，由服务器返回，用 GMT 格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT。

 **Cache-Control:** Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在 http1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个**相对时间**，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000。

3. Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。
4. 这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。

### 协商缓存？
1. 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。
2. 协商缓存是利用的是**【Last-Modified，If-Modified-Since】** 和 **【ETag、If-None-Match】**这两对Header来管理的。

### 浏览器行为对缓存的影响?
1. 如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会**先检查是否命中强缓存**，如果强缓存命中则直接读取缓存，**如果强缓存没有命中则发请求到服务器检查是否命中协商缓存**，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式。
2. 以下行为可能改变缓存的默认处理方式
 - 当`ctrl+f5`强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
 - 当`f5`刷新网页时，跳过强缓存，但是会检查协商缓存。

### 请列举三种禁止浏览器缓存的头字段, 并写出相应的设置值？
1. Expires: 告诉浏览器把回送的资源缓存多长时间  -1或0则是不缓存
2. Cache-Control: no-cache
3. Pragma: no-cache

### 永久登录？
只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。

实现方式是把账号按照一定的规则加密后，连同账号一块保存到Cookie中。下次访问时只需要判断账号的加密规则是否正确即可。

本例把账号保存到名为account的Cookie中，把账号连同密钥用MD1算法加密后保存到名为ssid的Cookie中。验证时验证Cookie中的账号与密钥加密后是否与Cookie中的ssid相等。

提示：该加密机制中最重要的部分为算法与密钥。由于MD1算法的不可逆性，即使用户知道了账号与加密后的字符串，也不可能解密得到密钥。因此，只要保管好密钥与算法，该机制就是安全的。

### 三次握手，四次挥手？
建立TCP连接需要三次握手，而断开连接需要执行四次挥手。

**三次握手：**
* 第一步: 客户机的TCP先向服务器的TCP**发送一个连接请求报文**. 这个特殊的报文中不含应用层数据, 其首部中的**SYN标志位被置1**. 另外, 客户机会随机选择一个起始序号**seq=x**(连接请求报文不携带数据,但要消耗掉一个序号)
* 第二步: 服务器端的TCP收到连接请求报文后, 若同意建立连接, 就向客户机发送请求, 并为该TCP连接**分配TCP缓存和变量**. 在确认报文中,**SYN和ACK位都被置为1**, 确认号字段的值为**x+1**, 并且服务器随机产生起始序号**seq=y**(确认报文不携带数据, 但也要消耗掉一个序号). 确认报文同样不包含应用层数据.
* 第三步: 当客户机收到确认报文后, 还要向服务器给出确认, 并且也要给该连接**分配缓存和变量**. 这个报文的**ACK标志位被置为1**, 序号字段为**x+1**, 确认号字段为**y+1**

**四次挥手：**
* 第一步: 客户机打算关闭连接,就向其TCP发送一个**连接释放报文**,并停止再发送数据,**主动关闭TCP连接**, 该报文的**FIN标志位被置1, seq=u**，它等于前面已经传送过的数据的最后一个字节的序号加1(FIN报文即使不携带数据,也要消耗掉一个序号)
* 第二步: 服务器接收连接释放报文后即发出确认, 确认号是**ack=u+1**, 这个**报文自己的序号是v**, 等于它前面已传送过的数据的最后一个自己的序号加1. 此时, 从客户机到服务器这个方向的连接就释放了, TCP连接处于**半关闭状态**. 但服务器若发送数据, 客户机仍要接收, 即从服务器到客户机的连接仍未关闭.
* 第三步: 若服务器已经没有了要向客户机发送的数据, 就**通知TCP释放连接**, 此时其发出**FIN=1**的连接释放报文
* 第四步: 客户机收到连接释放报文后, 必须发出确认. 在确认报文中, **ACK字段被置为1**, 确认号**ack=w+1, 序号seq=u+1**. 此时, TCP连接还没有释放掉, 必须经过等待计时器设置的时间2MSL后, A才进入到连接关闭状态.

### http常见状态码？
- 1开头 （信息性状态码）接收的请求正在处理
- 2开头 （成功状态码）表示成功处理了请求的状态代码
  * 200 Ok：请求被正确处理
  * 204 No Content：请求被成功处理，但服务器不返回任何实体，用于只需向服务器发送信息而不需要服务器返回信息的场景
  * 206 Partial Content：范围请求，响应报文包含有content-range描述的范围实体。
- 3开头 （重定向状态码）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
  * 301 Moved Permanently：永久性重定向，请求的资源已被分配了新的URI
  * 302 Found：临时性重定向
  * 303 See Other：请求资源存在另一个URI，应使用GET方法获取资源
  * 304 Not Modified：协商缓存，表示请求资源没有修改可，以直接使用浏览器缓存
  * 307 Temporary Redirect：临时性重定向，不会将 POST 变成 GET
- 4开头 （客户端错误状态码）服务器无法处理请求，请求有误
  * 400 Bad Request：请求报文包含语法错误
  * 401 Unauthorized：请求需要 http 认证信息
  * 403 Forbidden：请求被服务器拒绝
  * 404 Not Found：服务器无法找到请求的资源
- 5开头（服务器错误状态码）服务器处理请求出错，服务器本身有误
  * 500 Internal Server Error：服务器在执行请求时出错
  * 503 Service Unavailable：服务器处于超负载或停机维护状态

### http 报文结构？
HTTP请求报文解剖：https://yq.aliyun.com/articles/44672

1. 请求报文
 - 请求行：请求方法、URI、http版本。如 `POST /rest/ HTTP/1.1`
 - 首部字段：Accept、Accept-Encoding、Accept-Language、UserAgent、Content-Length、Content-Type、Referer、Origin、Connection、Host...
 - 请求主体：key=value & key=value

2. 响应报文
 - 状态行：http版本、状态码。如 `HTTP/1.1 200 OK`
 - 首部字段：Date、Content-Length、Content-Type、Accept-Ranges、Server
 - 响应主体：xml、html、json...


### http请求和响应头？
1. HTTP请求头

  accept：浏览器通过这个头告诉服务器，它所支持的数据类型。如：text/html, image/jpeg。

  accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集。

  accept-encoding：浏览器通过这个头告诉服务器，它支持哪种压缩格式。

  accept-language：浏览器通过这个头告诉服务器，它的语言环境。

  host：浏览器通过这个头告诉服务器，它想访问哪台主机。

  if-modified-since：浏览器通过这个头告诉服务器，缓存数据的时间。

  referer：浏览器通过这个头告诉服

2. HTTP响应头

  location：服务器通过这个头告诉浏览器跳到哪里。

  server：服务器通过这个头告诉浏览器服务器的型号。

  content-encoding：服务器通过这个头告诉浏览器数据的压缩格式。

  content-length：服务器通过这个头告诉浏览器回送数据的长度。

  content-language：服务器通过这个头告诉浏览器语言环境。

  content-type：服务器通过这个头告诉浏览器回送数据的类型。

  refresh：服务器通过这个头告诉浏览器定时刷新。

  content-disposition：服务器通过这个头告诉浏览器以下载方式打开数据。

  transfer-encoding：服务器通过这个头告诉浏览器数据是以分块方式回送的务器，客户机是哪个页面来的(防盗链)。

  Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是维持链接。


### WebSocket 原理？
WebSocket：5分钟从入门到精通: https://juejin.im/post/5a4e6a43f265da3e303c4787


### 前端优化一般都做哪些？

[详情地址](https://www.zhihu.com/question/21658448)


### 浏览器内核？常见兼容性问题？常用hack技巧？

[详情](https://zhuanlan.zhihu.com/p/27447843)

IE：Trident

Mozilla: Gecko

Goole: webkit

Opera: Presto

浏览器默认margin、padding不同。解决办法是加一个全局的。

### gzip压缩？

GZIP，即网页压缩，是由WEB服务器和浏览器之间共同遵守的协议，也就是说WEB服务器和浏览器都必须支持该技术，而现在主流的浏览器都是支持的，包括IE、FireFox、谷歌浏览器、Opera 等。常见的WEB服务器有Apache 和IIS 等。双方的协商过程如下：

1、首先浏览器请求某个URL 地址，并在请求的头 (head) 中设置属性accept-encoding值为gzip、deflate，表明浏览器支持gzip和deflate这两种压缩方式。

（注：gzip是一种数据压缩格式，默认且目前仅使用deflate算法压缩data部分；deflate是一种压缩算法,是huffman编码的一种加强。）

2、WEB服务器接收到请求后判断浏览器是否支持压缩，如果支持就传送压缩后的响应内容，否则传送不经过压缩的内容；

3、浏览器获取响应内容后，判断内容是否被压缩，如果是则解压缩，然后显示响应页面的内容。（IE5.5以上才支持gzip）

GZIP压缩的比率往往在3到10倍，也就是本来90k大小的页面，采用压缩后实际传输的内容大小只有28至30K大小，这可以大大节省服务器的网络带宽，同时如果应用程序的响应足够快时，网站的速度瓶颈就转到了网络的传输速度上，因此内容压缩后就可以大大的提升页面的浏览速度。

**web服务器处理http压缩的过程：**
1. Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）；

2. 如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名；

3. 如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件；

4. 如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件；

5. 如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件；

6. 如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。

在HTTP1.1开始，Web客户端可以通过**Acceppt-Encoding**请求头来标识对压缩的支持。服务端响应头标识**content-encoding:gzip**采用的压缩方法。


### 如何提高数据传输性能？
- 采用 gzip 压缩
- 简化数据结构和字段长度
- 对某些数据编码

### XSS是什么，攻击原理，怎么预防？
http://blog.csdn.net/qq_21956483/article/details/54377947

**定义：**

XSS攻击是Web攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器
执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列
表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实
施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨
大的，是web安全的头号大敌。

**攻击条件：**
1. 向web页面注入恶意代码；
2. 这些恶意代码能够被浏览器成功的执行。

**攻击类型：**
1. XSS**反射型**攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。
2. XSS**存储型**攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，黑客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击。

**解决办法：**
1. 在表单提交或url参数传递前对参数进行过滤。如：过滤html字符，过滤非法js和css，url参数编码等
2. 过滤用户输入的字符，检查用户输入的内容中是否有非法内容。如<>（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&（& 符号）、+（加号）等。严格控制输出。
3. 不要进入不安全的网站、不要提交敏感信息。

### CRSF:跨站请求伪造？
**定义：**
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。

**CSRF的常见特性：**
- 依靠用户标识危害网站
- 利用网站对用户标识的信任
- 欺骗用户的浏览器发送HTTP请求给目标站点
- 另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。

**CSRF攻击依赖下面的假定：**
- 攻击者了解受害者所在的站点
- 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie
- 目标站点没有对用户在网站行为的第二授权

**解决办法：**
利用Token。

Token，就是令牌，最大的特点就是随机性，不可预测。一般黑客或软件无法猜测出来。

Token一般用在两个地方:

1)防止表单重复提交、

2)anti csrf攻击（跨站点请求伪造）。

两者在原理上都是通过session token来实现的。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。

然后，如果应用于“anti csrf攻击”，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。

不过，如果应用于“防止表单重复提交”，服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。
