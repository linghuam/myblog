---
title: 前端面试-浏览器
comments: true
date: 2018-01-30 23:41:20
tags:
  - 浏览器
categories:
  - 前端面试
---

## 浏览器
<!-- more -->

### 浏览器渲染原理?

**过程：**解析 HTML 构建 DOM 树、解析 CSS 构建 Render 树 -> Layout -> Paint -> Composite。

期间可引起重绘和重排。

**减少重绘和重排方法：**
 - 不要频繁操作 DOM，应该合并处理；
 - position 设为 fixed 或 absolute；
 - 不要用 table 布局；
 - 尽量使用 css 动画。


### HTML页面加载和解析流程?
1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；
2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；
3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件；
4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；
5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；
6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；
7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；
8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；
9. 终于等到了＜/html＞的到来，浏览器泪流满面……
10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；
11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。


### session、cookie、sessionStorage、localStorage等区别?
详见：http://www.jb51.net/article/122101.htm

cookie存储在客户端，session存储在服务端，通过 session id 来识别客户端， session id存储在cookie中或url中。

当客户端第一次请求session对象时，服务端生成一个id并发送给客户端，客户端在下次请求时，再将这个id发送给服务端。

cookie安全性不好，session安全，但服务端压力大。


### http？[详解](https://www.jianshu.com/p/6aa2fda4d4a1)

**协议分层：** http应用层 ——> TCP传输层 ——> IP网络层 ——> 链路层（网络接口）——> 物理层（网卡）

**封装：**发送端在层与层传输数据时，每经过一层必定会打上改成所属的首部信息；接收端在层与层传输数据
时，每经过一层会把对应的首部消去。

三次握手策略：


### http 请求方法？

HTTP1.0定义了三种请求方法：GET, POST 和 HEAD方法。

HTTP1.1新增了五种请求方法：PUT, DELETE, OPTIONS, TRACE 和 CONNECT 方法。

1. | GET | 请求指定的页面信息，并返回实体主体。
2. | HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
3. | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4. | PUT | 从客户端向服务器传送的数据取代指定的文档的内容。
5. | DELETE | 	请求服务器删除指定的页面。
6. | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7. | OPTIONS | 询问的请求，如CORS的预检请求。允许客户端查看服务器的性能。
8. | TRACE | 回显服务器收到的请求，主要用于测试或诊断。

### https？

加密处理防止窃听。可通过SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输协议）的组合使用，加密通信。与SSL组合使用的HTTP叫HTTPS。


### 从输入网址到看到页面的过程？


### post、get区别？
1. 本质都是 TCP 连接，并无区别，只是贴上不同的标签，便于处理；
2. get 只产生一个 TCP 数据包， post 产生两个 TCP数据包；
3. get 在一次请求中将 header 和 data 发送给服务器，服务器返回 200；
4. post 先发送 header 再 发送 data；


### 缓存？

- 200 ok ：当浏览器没有缓存，或用户强制刷新，浏览器直接获取最新数据。
- 304：由 last-modified/etag 控制。先发送请求到服务器，如果没有变化，返回304。
- 200 from cache：由 expires/cache-control 控制。

策略：[详情](http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html)
- Expires 缺点:绝对时间
- Cache-Control 相对时间 max-age 控制缓存在时间
- Last-Modified/If-Modified-Since
- Etag/If-None-Match


### http常见状态码？

- 2开头 （请求成功）表示成功处理了请求的状态代码。
- 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
- 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
- 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

### http请求头和响应头？
1. HTTP请求头

  accept：浏览器通过这个头告诉服务器，它所支持的数据类型。如：text/html, image/jpeg。

  accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集。

  accept-encoding：浏览器通过这个头告诉服务器，它支持哪种压缩格式。

  accept-language：浏览器通过这个头告诉服务器，它的语言环境。

  host：浏览器通过这个头告诉服务器，它想访问哪台主机。

  if-modified-since：浏览器通过这个头告诉服务器，缓存数据的时间。

  referer：浏览器通过这个头告诉服

2. HTTP响应头

  location：服务器通过这个头告诉浏览器跳到哪里。

  server：服务器通过这个头告诉浏览器服务器的型号。

  content-encoding：服务器通过这个头告诉浏览器数据的压缩格式。

  content-length：服务器通过这个头告诉浏览器回送数据的长度。

  content-language：服务器通过这个头告诉浏览器语言环境。

  content-type：服务器通过这个头告诉浏览器回送数据的类型。

  refresh：服务器通过这个头告诉浏览器定时刷新。

  content-disposition：服务器通过这个头告诉浏览器以下载方式打开数据。

  transfer-encoding：服务器通过这个头告诉浏览器数据是以分块方式回送的务器，客户机是哪个页面来的(防盗链)。

  Connection：浏览器通过这个头告诉服务器，请求完后是断开链接还是维持链接。

2. HTTP响应头
location：服务器通过这个头告诉浏览器跳到哪里。
server：服务器通过这个头告诉浏览器服务器的型号。
content-encoding：服务器通过这个头告诉浏览器数据的压缩格式。
content-length：服务器通过这个头告诉浏览器回送数据的长度。
content-language：服务器通过这个头告诉浏览器语言环境。
content-type：服务器通过这个头告诉浏览器回送数据的类型。
refresh：服务器通过这个头告诉浏览器定时刷新。
content-disposition：服务器通过这个头告诉浏览器以下载方式打开数据。
transfer-encoding：服务器通过这个头告诉浏览器数据是以分块方式回送的
### 前端优化一般都做哪些？

[详情地址](https://www.zhihu.com/question/21658448)


### 浏览器内核？常见兼容性问题？常用hack技巧？

[详情](https://zhuanlan.zhihu.com/p/27447843)

IE：Trident

Mozilla: Gecko

Goole: webkit

Opera: Presto

浏览器默认margin、padding不同。解决办法是加一个全局的。

### gzip压缩？

GZIP，即网页压缩，是由WEB服务器和浏览器之间共同遵守的协议，也就是说WEB服务器和浏览器都必须支持该技术，而现在主流的浏览器都是支持的，包括IE、FireFox、谷歌浏览器、Opera 等。常见的WEB服务器有Apache 和IIS 等。双方的协商过程如下：

1、首先浏览器请求某个URL 地址，并在请求的头 (head) 中设置属性accept-encoding值为gzip、deflate，表明浏览器支持gzip和deflate这两种压缩方式。

（注：gzip是一种数据压缩格式，默认且目前仅使用deflate算法压缩data部分；deflate是一种压缩算法,是huffman编码的一种加强。）

2、WEB服务器接收到请求后判断浏览器是否支持压缩，如果支持就传送压缩后的响应内容，否则传送不经过压缩的内容；

3、浏览器获取响应内容后，判断内容是否被压缩，如果是则解压缩，然后显示响应页面的内容。（IE5.5以上才支持gzip）

GZIP压缩的比率往往在3到10倍，也就是本来90k大小的页面，采用压缩后实际传输的内容大小只有28至30K大小，这可以大大节省服务器的网络带宽，同时如果应用程序的响应足够快时，网站的速度瓶颈就转到了网络的传输速度上，因此内容压缩后就可以大大的提升页面的浏览速度。

**web服务器处理http压缩的过程：**
1. Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）；

2. 如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名；

3. 如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件；

4. 如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件；

5. 如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件；

6. 如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。

在HTTP1.1开始，Web客户端可以通过**Acceppt-Encoding**请求头来标识对压缩的支持。服务端响应头标识**content-encoding:gzip**采用的压缩方法。


### 如何提高数据传输性能？
- 采用 gzip 压缩
- 简化数据结构和字段长度
- 对某些数据编码

### XSS是什么，攻击原理，怎么预防？
http://blog.csdn.net/qq_21956483/article/details/54377947

**定义：**

XSS攻击是Web攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器
执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列
表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实
施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨
大的，是web安全的头号大敌。

**攻击条件：**
1. 向web页面注入恶意代码；
2. 这些恶意代码能够被浏览器成功的执行。

**攻击类型：**
1. XSS**反射型**攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。
2. XSS**存储型**攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，黑客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击。

**解决办法：**
1. 在表单提交或url参数传递前对参数进行过滤。如：过滤html字符，过滤非法js和css，url参数编码等
2. 过滤用户输入的字符，检查用户输入的内容中是否有非法内容。如<>（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&（& 符号）、+（加号）等。严格控制输出。
3. 不要进入不安全的网站、不要提交敏感信息。

### CRSF:跨站请求伪造？
**定义：**
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。

**CSRF的常见特性：**
- 依靠用户标识危害网站
- 利用网站对用户标识的信任
- 欺骗用户的浏览器发送HTTP请求给目标站点
- 另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。

**CSRF攻击依赖下面的假定：**
- 攻击者了解受害者所在的站点
- 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie
- 目标站点没有对用户在网站行为的第二授权

**解决办法：**
利用Token。

Token，就是令牌，最大的特点就是随机性，不可预测。一般黑客或软件无法猜测出来。

Token一般用在两个地方:

1)防止表单重复提交、

2)anti csrf攻击（跨站点请求伪造）。

两者在原理上都是通过session token来实现的。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。

然后，如果应用于“anti csrf攻击”，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。

不过，如果应用于“防止表单重复提交”，服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。
